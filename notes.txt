0 -> 0000 0000
1 -> 0000 0001
2 -> 0000 0010
3 -> 0000 0100
4 -> 0000 1000
5 -> 0000 0101
6 -> 0000 0110
7 -> 0000 0111
8 -> 0000 1000
9 -> 0000 1001
10 -> 0000 1010

a -> 0110 0001 == 97
A -> 0100 0001 == 65


    S		a	   r	      t		 h	    a	       k
0101 0011   0110 0001	0111 0011  0111 0100  0110 1000  0110 0001  0110 1011

01010011011000010111001101110100011010000110000101101011 -> Sarthak

This is a 7-byte or 56 bits message
Needs to be converted into a 256 by padding

add '1' after every message => 01010011 01100001 01110011 01110100 01101000 01100001 01101011 1

==> 56 bits + 1 == 57 bits

We need to reach 448
so, 448-57 == 391
so we add 391 zeros => 01010011 01100001 01110011 01110100 01101000 01100001 01101011 1 + [391 zeros]

final padded message : 01010011 01100001 01110011 01110100 01101000 01100001 01101011 1 + [391 zeros] + 0000000000000000000000000000000000000000000000000000000000111000

For Initial hash values:
- root 2 => 1.414
- root 3 => 1.732
- root 5 => 2.236

Extract fractional part:
- root 2 => 0.414
- root 3 => 0.732

so, 2^32 -> 4294967296
scale => 0.414*4294967296 => 1779033703.676
int part => 1779033703

Converting to hexaDecimals
1779033703 ÷ 16 = 111189606 (remainder 7)
111189606 ÷ 16 = 6949350 (remainder 6)
6949350 ÷ 16 = 434334 (remainder 6)
434334 ÷ 16 = 27145 (remainder 14 → E)
27145 ÷ 16 = 1696 (remainder 9)
1696 ÷ 16 = 106 (remainder 0)
106 ÷ 16 = 6 (remainder 10 → A)
6 ÷ 16 = 0 (remainder 6)


6A09E667

Simpler example
01010011 1 -> padding 1

01010011 10000000 0000000 ... (439 zeros)

so binary: 
01010011 10000000 00000000 00000000 00000000 00000000 00000000 00000000
00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000
00000000 00000000 00000000 00000000 00000000 00000000 00000000 00001000

512-bit message grouped into 32 bit blocks

Hex:
53400000 00000000 00000000 00000000
00000000 00000000 00000000 00000000
00000000 00000000 00000000 00000008

01010011 -> 53
10000000 -> 40
remaining 32 -> zeros
last 64 bits -> 0000008

Message Scheduling in SHA-256
W_t = σ1(W_t−2) + W_t−7 + σ0(W_t−15) + Wt−16

for t = 16 to 63

Breaking down the formula:

- W_t

- σ1(W_t−2)
==> σ1(x) = ROTR^17(x)⊕ROTR^19(x)⊕SHR^10(x)

ROTR => rotate shift 
SHR => shift right

- W_{t-7} 
- σ0(x)=ROTR^7(x)⊕ROTR^18(x)⊕SHR^3(x)

- W_{t-16}

Calculations:
53400000 00000000 00000000 00000000
00000000 00000000 00000000 00000000
00000000 00000000 00000000 00000008

W₀ = 53400000
W₁ = 00000000
W₂ = 00000000
...
W₁₅ = 00000008

Compute remaining 48 words:
W_t = σ1(W_t−2) + W_t−7 + σ0(W_t−15) + Wt−16

Index	Word (Hex)	Word (Binary)
W₀	53400000	01010011010000000000000000000000
W₁	00000000	00000000000000000000000000000000
W₂	00000000	00000000000000000000000000000000
W₃	00000000	00000000000000000000000000000000
W₄	00000000	00000000000000000000000000000000
W₅	00000000	00000000000000000000000000000000
W₆	00000000	00000000000000000000000000000000
W₇	00000000	00000000000000000000000000000000
W₈	00000000	00000000000000000000000000000000
W₉	00000000	00000000000000000000000000000000
W₁₀	00000000	00000000000000000000000000000000
W₁₁	00000000	00000000000000000000000000000000
W₁₂	00000000	00000000000000000000000000000000
W₁₃	00000000	00000000000000000000000000000000
W₁₄	00000000	00000000000000000000000000000000
W₁₅	00000008	00000000000000000000000000001000

- σ0(x)=ROTR^7(x)⊕ROTR^18(x)⊕SHR^3(x)
- σ1(x)=ROTR^17(x)⊕ROTR^19(x)⊕SHR^10(x)

W14 = 00000000
W9 = 00000000
W1 = 00000000
w0 = 53400000

Compute σ1(W14):
σ1(00000000)=ROTR^17(00000000)⊕ROTR^19(00000000)⊕SHR^10(00000000)
result: 0

Compute σ1(W14):
σ0(00000000)=ROTR^7(00000000)⊕ROTR^18(00000000)⊕SHR^3(00000000)
result: 0

Compute W16
W16 = 0 + 0 + 0 + 534000000

Index	Computed Word (Hex)
W₀	53400000
W₁	00000000
W₂	00000000
W₃	00000000
W₄	00000000
W₅	00000000
W₆	00000000
W₇	00000000
W₈	00000000
W₉	00000000
W₁₀	00000000
W₁₁	00000000
W₁₂	00000000
W₁₃	00000000
W₁₄	00000000
W₁₅	00000008
W₁₆	53400000
W₁₇	00000008
W₁₈	Computed Next
W₁₉	Computed Next
W₂₀	Computed Next
...	...
W₆₃	Computed Next

